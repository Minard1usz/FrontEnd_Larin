// Tasks that could appear at an interview

// 1) Какое будет выведено значение: let x = 5; alert(x++); ?
// let x = 5; alert(x++);

// результат: 5. Постфиксная запись сначала вернёт изначальное значение, а уже потом задействует инкремент.
// Если использовать префиксную форму, тогда нам сразу вернут результат с инкрементом:
// let y = 5; alert(++y);


// 2) Чему равно такое выражение: [] + false - null + true?
[] + false - null + true
console.log([] + false);

// результат: false. Пустой массив в typeof() выдаёт строку. Если складывать строку с иным типом данных, получаем строку, либо false
[] + false - null + true
console.log([] + false - null);

// если отнять null, будет NaN (не математическая операция)
[] + false - null + true
console.log([] + false - null + true);
// результат: NaN


// 3) Что выдаст следующий код: let r = 1; let s = r = 2; alert(s);?
let r = 1;
let s = r = 2;
// alert(s);
// результат: 2. Цепочка справа налево. R получает 2, S изменяется на значение R. Последовательное присваивание.


// 4) Что выведет код: [] + 1 + 2?
console.log([] + 1 + 2);
// результат: "12". Пустой массив = строка. Строка конкатенирует последующие данные. 1+2=12.


// 5) Что выведет этот код: alert("1"[0])?
// alert("1"[0]);
// результат: undefined. Код начинается со строки, затем индекс в []. Строка имеет один символ, соответственно это 1.


// 6) Чему равно следующее выражение: 2 && 1 && null && 0 && undefined?
console.log(2 && 1 && null && 0 && undefined);
// результат: null. Логический оператор && спотыкается на первом false, которым является null
// Логический оператор || всегда запинается на первом true

// 7) Есть ли разница между выражениями: !!(a && b) и (a && b)?
// console.log(!!(a && b) || (a && b));
// результат: false. Два выражения не равны. Два знака !! превращают значение в булиновое. Булиновое значение не равняется значению справа.

console.log(!!(1 && 2));
console.log((1 && 2));
// результат: true, 2;


// *8) Что выведет этот код: alert(null || 2 && 3 || 4);?
            //  3
// alert(null || 2 && 3 || 4);
// результат: . Нужно пользоваться таблицей приоритетов операторов. Логическое && выше, чем логическое ||. 
// И запинается на лжи, ИЛИ запинается на правде: 2 && 3 выдаст последнее значение true
// null || 3 вернёт 3, первое true
// 3 || 4 выдаст 3, первое true


// *9) У нас есть a = [1, 2, 3]; b = [1, 2, 3]. Правда ли что а == b?
const a = [1, 2, 3];
const b = [1, 2, 3];
console.log(a == b);
// результат: false. У нас есть две переменные / хранилища с одинаковыми данными. Это как два ящика яблок, которые индентичны, но не являются одним и тем же ящиком.


// *10) Что виведет этот код: alert(+ "Infinity");?
// alert(+ "Infinity");
// результат: Infinity. Но это число, а не строка, потому что присутствует унарный +


// *11) Верно ли сравнение: "Ёжик" > "яблоко" ?
console.log("Ёжик" > "яблоко");
// результат: можно сравнить строки посимвольным сравнением. Нужно понимать таблицу юникода. "я" - это нижний регистр, который будет раньше, чем верхний + алфавит


// *12) Чему равно: 0 || "" || 2 || undefined || true || false ?
// ИЛИ запинается на первой правде
console.log(0 || "" || 2 || undefined || true || false);
// результат: 2 - первое true.